## <a name="Сharapter-6">Глава 6. Тесты</a>

Одной из ключевых преимуществ Redux является простота тестирования. Чтобы полностью автоматизировать набор тестов, мы можем создавать модульные тесты для каждого из участников (reducer, action creator и middleware) и объединять их для всесторонних интеграционных тестов.

Существует большое количество инструментов для тестирования. Большинство частей нашего Redux приложения будут зависеть от чистых JavaScript функций и объектов без сложных библиотек или асинхронных потоков.

В качестве нашей платформы тестирования мы будем использовать отличную библиотеку [Jest](https://facebook.github.io/jest/) от Facebook, последняя версия которой станет отличным выбором для тестирования Redux. При использовании других фреймворков и инструментов для тестирования, таких как Karma, Mocha и другие, реализация должна выглядеть очень похоже на примеры, разобранные в этой главе.

Что бы доблавить Jest в ваш проект и операционную систему, пройдите [руководство по старту](https://facebook.github.io/jest/docs/en/getting-started.html).

### <a name="Test-Files-and-Directories">Тестовые файлы и каталоги</a>

Для начала нам нужен способ организации наших тестов. Существует два основных подхода: объединение тестов в один каталог с файлами реализации или их размещение в отдельном каталоге. В этом руководстве мы будем использовать последнее. Это вопрос удобства и личных предпочтений, вы можете выбрать то, что вам больше нравится. При этом единственными отличием будут различные конфигурации запуска тестов.

Мы создадим отдельный тестовый файл для каждого файла реализации в нашем проекте. В случае _app/actions/recipes.js_, нашим тестовым файлом будут _test/actions/recipes.test.js_.

#### Структура тестового файла

В наших тестовых файлах мы будем использовать функцию _describe()_ как обертку всех наших тестов. Первый строковый параметр в этой функции позволит нам легко определить, какая группа тестов проваливается или успешно выполняется:

_Пример структуры тестового файла_
```javascript
describe('actions', () => {
  // TODO: Добавить тесты
});
```

Внутри этой функции могут использоваться другие вложенные функции _describe()_, чтобы дополнительно различать разные наборы состояний (например, тестирование неудачных или последующих вызовов API).

Каждый тест в Jest обернут внутри блока _it()_, описывающего, что делает тест. Чтобы тесты были читабельны и понятны, обычно рекомендуется создавать как можно больше коротких тестов (каждый в своем собственном блоке _it()_), а не создавать очень большие одиночные тестовые функции:

_Пример тестового файла с описанием тестов_
```javascript
describe('actions', () => {
  it('должен создать action для добавления рецепта', () => {
    // TODO: Реализовать тест
  });
 
  it('должен создать action для удаления рецепта', () => {
    // TODO: Реализовать тест
  });
});
```

### <a name="Testing-Action-Creators">Тестирование Action Creators</a>

Всюду по этой книге мы пытались хранить асинхронные потоки вне action creator, переместив их в middleware и утилитарные функции. Этот подход позволяет очень легко тестировать action creators, поскольку они представляют собой функции, которые просто возвращают обычные JavaScript объекты:

_Пример action creator_
```javascript
import * as actions from 'constants/action-types';
 
export const setRecipes = (recipes) => ({
 type: actions.SET_RECIPES,
 payload: recipes
});
```

Наш action creator _setRecipes()_ получает единственный параметр и создает в результате простой JavaScript объект. Поскольку здесь нет логики управления потоком или каких-либо побочных эффектов, любой вызов этой функции всегда возвращает одно и то же значение, что делает его очень простым для тестирования:

_Пример теста для setRecipes_
```javascript
import * as actions from 'actions'
 
describe('actions', () => {
 it('должен создать action для добавления рецепта', () => {
   const expected = { type: 'ADD_RECIPE', payload: 'test' };
   const actual = actions.addRecipe('test');
   
   expect(actual).toEqual(expected);
 });
});
```

Этот тест построен в трех частях. Во-первых, мы вычисляем, что должен сделать наш action creator при вызове с _'test'_ в качестве аргумента - в этом случае объект JavaScript, содержащий два ключа, _type_ и _payload_:

_Рассчет ожидаемого результата_
```javascript
const expected = { type: 'ADD_RECIPE', payload: 'test' };
```

Во-вторых, вызывается action creator _actions.addRecipe('test')_, чтобы получить значение, созданное реализацией нашего action creator:

_Рассчет фактического результата_
```javascript
const actual = actions.addRecipe('test');
```

И наконец используются Jest функции  _expect()_ и _toEqual()_ для проверки того, что фактические и ожидаемые результаты одинаковы:

_Проверка соответствия результатов_
```javascript
expect(actual).toEqual(expected);
```

Если ожидаемые и фактические объекты различаются, Jest выдаст ошибку и предоставит информацию, описывающую различия, что позволит нам отловить неправильные реализации.

#### Улучшение кода

Из-за простоты этого кода принято комбинировать несколько этапов в один вызов и переписывать тест следующим образом:

_Более короткая версия теста_
```javascript
it('должен создать action для добавления рецепта', () => {
 const expected = { type: 'ADD_RECIPE', payload: 'test' };
 
 expect(actions.addRecipe('test')).toEqual(expected);
});
```

#### Использование снимков (Snapshot)

Подход вычисления ожидаемого значения, а затем сравнение его с динамически рассчитанными значениями очень распространен в Redux тестах. Что бы сохранить время на набор текста и облегчить чтение кода, мы можем использовать одну из возможностей Jest - [снимков](https://facebook.github.io/jest/docs/en/tutorial-react.html#snapshot-testing) (snapshot).

Вместо того, что бы вручную строить ожидаемый результат, мы можем попросить Jest запустить блок _expect()_ и сохранить результат в специальном файле .snap, генерирующим на ожидаемый объект автоматически: 

_Тест с использованием снимков_
```javascript
it('должен создать action для добавления рецепта', () => {
  expect(actions.addRecipe('test')).toMatchSnapshot();
});
```

Ожидаемый значение рассчиталось и вместо использования _isEqual()_, Jest теперь сравнивает результат выражения внутри _expect()_ с версией, сохраненной на диске. Фактически снимок помещается в каталог __snapshots__ в файл с тем же именем, что и тестовый файл, а также расширением .snap:

_snapshots/action.test.js.snap_
```javascript
exports[`должен создать action для добавления рецепта`] = `
Object {
  "payload": "test",
  "type": "ADD_RECIPE",
}
`;
```

Структура сложнее, чем структура обычного объекта JavaScript, но результат точно такой же, как и наш первоначальный ожидаемый расчет:

_Рассчитанный ожидаемый результат_
```javascript
const expected = { type: 'ADD_RECIPE', payload: 'test' };
```

Что происходит, когда изменяется наш код? В некоторых случаях мы хотим намеренно изменить структуру нашего объекта action. В этих случаях Jest обнаружит, что возвращаемое значение не соответствует тому, что сохраняется в его файле снимков, и выдаст ошибку. Но если мы укажем, что новый результат является правильным, а кешированный снимок уже недействителен, мы можем легко сказать Jest обновить его версию снимка до новой.
 
 #### Динамические Action Creators

В некоторых случаях action creator может содержать логику, которая испускает разные объекты action на основе входных параметров. До тех пор, пока не будет затронут асинхронный код или другие внешние объекты (например, localStorage), мы можем легко протестировать логику, предоставив различные входные параметры для action creator проверив, что он каждый раз создает правильный объект:

_Action creator c изменяемыми входными параметрами_
```javascript
export const addRecipe = (title) => ({
  type: actions.ADD_RECIPE,
  payload: title || "Default"
});
```

Модифицированный action creator _addRecipe()_ установит значение _"Default"_, если пользователь не передаст заголовок. Чтобы проверить это поведение, мы можем создать два теста, один из которых передает параметр (как мы уже делали), и второй, который передает пустую строку. Полностью всеобъемлющий тест может содержать несколько случаев "пустой строки", а именно значение _null_, _undefined_ и ' ':

_Комбинированный тест нескольких входных значений пустой строки_
```javascript
it('должен добавить рецепт с параметром по умолчанию', () => {
  expect(actions.addRecipe(undefined)).toMatchSnapshot();
  expect(actions.addRecipe(null)).toMatchSnapshot();
  expect(actions.addRecipe('')).toMatchSnapshot();
});
```

В отличие от того, что мы обсуждали ранее, здесь мы попытались включить несколько функций _expect()_ в один и тот же тест. Хотя этот подход будет работать, но, в случае ошибки, будет сложно определить, какие из тестовых случаев не удались.
 
Поскольку мы используем JavaScript для написания наших тестов, мы можем легко создавать тестовые случаи для каждого входного значения без значительного увеличения размера нашего кода (создавая _it()_ для каждого случая). Мы можем сделать это, добавив все возможные входные параметры в массив и автоматически создав соответствующие _it()_ блоки:

_Автоматическое создание тестов для каждого тестового случая_
```javascript
[undefined, null, ''].forEach((param) =>
 it(`должен добавить рецепт с параметром по умолчанию ${param}` , () => {
   expect(actions.addRecipe(param)).toMatchSnapshot()
 }));
```

Используя этот подход, мы получаем три разных блока _it()_, автоматически генерируемых JavaScript, сохраняя наши тесты чистыми, а код - коротким.

### <a name="Async-Action-Creators">Async Action Creators</a>

Везде в этой книге мы пытались препятствовать использованию async action creator (создатели асинхронных действий) и функций, которые имеют побочные эффекты. Для этого мы использовали различные библиотеки, такие как [redux-thunk](https://github.com/gaearon/redux-thunk), что бы позволить action creator запланировать асинхронную работу. Одним из основных преимуществ обычных action creators является простота их тестирования - больше информации об этом можно найти в главе [Action Creators](#Charapter-8).

В нашем примере бы создадим простой async action creator, который, используя _redux-thunk_ и метод _fetch()_, получит данные о рецепте с сервера и отправит (dispatch) результат с помощью действия _SET_RECIPE_:

_Async action creator_
```javascript
 export const setRecipe = (id, data) => ({
   type: actions.SET_RECIPE,
   payload: { id, data }
 });
 
 export const fetchRecipe = id => dispatch => {
   return fetch('recipe/' + id)
     .then(response => response.json())
     .then(json  dispatch(setRecipe(id, json)))
 }
```

С помощью _redux-thunk_ наш action creator может вернуть функцию вместо чистого JavaScript объекта. middleware, которую предоставляет _redux-thunk_, может вызвать такие функции и передать им методы _dispatch()_ и _getState()_. Такая реализация позволяет нашему action creator использовать метод fetch() для получение данных с сервера и отправить action, когда эти данные будут получены, используя _dispatch()_.

#### Переопределение fetch()

Прежде чем перейти к тестам, нам нужно определить некоторую инфраструктуру для переопределения метода _fetch()_. Мы создадим фиктивный объект ответа, а затем переопределим _fetch()_ на нашем объекте window:

_Создадим фейковый объект ответа_
```javascript
export const mockResponse = (status, statusText, response) => {
  return new window.Response(response, {
    status: status,
    statusText: statusText,
    headers: {
      'Content-type': 'application/json'
    }
  });
};
```

_Переопределение успешно завершенного метода fetch()_
```javascript
export const mockFetch = (status, data) => {
  window.fetch = jest.fn().mockImplementation(
    () => Promise.resolve(mockResponse(status, null, data)));
};
```

_Переопределение не успешно завершенного метода fetch()_
```javascript
export const mockFetchError = (state, error) => {
  window.fetch = jest.fn().mockImplementation(
    () => Promise.reject(mockResponse(state, error, '{}'))
  );
};
```

Вызов нашего фиктивного _fetch()_ вернет обещание, подобное реальному результату при вызове _fetch()_.

_Пример подмены метода fetch()_
```javascript
mockFetch(200, '{"key":"value"}');
fetch('test.json')
```

Этот код позволит нам вызвать _mockFetch()_ или _mockFetchError()_, в результате чего следующий вызов функции _fetch()_ будет возвращаться с нашим фейковым ответом. Единственная проблема с этой реализацией заключается в том, что она переопределяет все вызовы _fetch()_ в системе, независимо от URL-адреса.

Поскольку первым параметром для _fetch()_ является URL-адрес, мы можем использовать простую функцию _handleResponse()_, чтобы сначала проверить, что URL-адрес, переданный в _fetch()_, является URL-адресом, который мы хотим переопределить:

_Переопределение с проверкой URL-адреса_
```javascript
const handleResponse = (mockedUrl, response) =>
  window.fetch = jest.fn().mockImplementation(url => {
    if (url === mockedUrl) {
      return response;
    }
    throw('Unknown URL: ' + url);
  });
 
export const mockFetch = (mockedUrl, status, data) =>
  handleResponse(
    mockedUrl,
    Promise.resolve(mockResponse(status, null, data)));
 
export const mockFetchError = (mockedUrl, state, error) =>
  handleResponse(
    mockedUrl,
    Promise.reject(mockResponse(state, error, '{}')));
```

#### Создание фейкового Store

В отличии от простых action creators, наш код теперь зависит от использования _dispatch()_, что заставляет нас создавать фейковый экземпляр кода. Для этого мы будем использовать библиотеку [redux-mock-store](https://github.com/arnaudbenard/redux-mock-store):

_Создание фейкового Store_
```javascript
import configureStore from 'redux-mock-store';
import thunk from 'redux-thunk';
 
const mockStore = configureStore([ thunk ]);
```

Здесь мы создаем объект фейкового store с одной middleware. Этот объект можно использовать как обычный Redux store. Он поддерживает отправку действий, которые позже позволят нам определить, что в store был отправлен корректный набор действий.

### Структура теста для Async Action Creator

Поскольку async action creators (создатели асинхронных действий) могут содержать разные потоки на основе результата асинхронного действия, лучше всего включить их в свои собственные блоки _describe()_ в тестах. Это также позволит нам легко создать новый «фейковый store» для каждого из тестовых примеров с использованием Jest's метода _beforeEach()_:

_Структура асинхронного тестового блока_
```javascript
describe('fetch recipe', () => {
  let store;
 
  beforeEach(() => store = mockStore({}));
 
  it('должен получать рецепт, если он существует'), () => {
      ...
  }
});
```

Наш фейковый store автоматически создается заново перед каждой итерацией тестов, очищая любые действия, кэшированные из предыдущего запуска.

#### Базовый тест Async Action Creator

Jest обрабатывает асинхронные тесты, позволяя нам вернуть promise (обещание) в качестве результата теста. Если обещание будет возвращено, Jest будет ждать пока оно не завершится и только потом перейдет к следующему тесту:

_Асинхронный тест_
```javascript
it('должен получать рецепт, если он существует', () => {
  return store.dispatch(actions.fetchRecipe(100));
});
```

Поскольку _store.dispatch()_ в этом случае вернет обещание (помните, наш action creator _fetchRecipe()_ возвращает вызов _fetch()_), мы можем использовать это для создания асинхронного теста.

Чтобы добавить в код блок _expect()_, мы можем использовать тот же promis и запустить наши тесты, как только он будет разрешен:

_Добавление ожидающих вызовов для асинхронных тестов_
```javascript
it('должен получать рецепт, если он существует', () => {
  return store.dispatch(actions.fetchRecipe(100))
    .then(() => expect(store.getActions()).toEqual([]))
});
```

Блок _expect()_ похож на то, что мы использовали в наших предыдущих тестах. Мы используем метод _getActions()_ нашего фейкового stor, что бы получить массив всех действий, отправленных в store. В нашей реализации мы ожидаем успешное завершение вызова _fetch()_ для отправки результата _setRecipe()_ нашего action creator. 

Выполнение этого теста сейчас приведет к неудаче, поскольку мы не подменили метод _fetch()_. Используя небольшую вспомогательную библиотеку, которую мы создали ранее, мы можем подменить его, что приведет к правильной последовательности действий:

_Полный асинхронный тест_
```javascript
it('должен получать рецепт, если он существует', () => {
  mockFetch('recipe/100', 200, '{"title":"hello"}');

  return store.dispatch(actions.fetchRecipe(100))
    .then(() => expect(store.getActions()).toMatchSnapshot())
});
```

Здесь мы подменяем успешным ответом (200) от _fetch()_ и ожидаем, что отправка асинхронного действия, созданного _fetchRecipe(100)_, приведет к последующей отправке действия, созданного _setRecipe()_.

#### Подведем итоги об асинхронных тестах

Как видно из этого минимального примера, тестирование async action creator (создателей асинхронных действий) значительно сложнее, чем тестирование обычных action creator. Если мы добавим надлежащую обработку ошибок и ветвление, тесты быстро станут очень трудными для анализа и построения.

Глава [Middleware](#Charapter-10) предлагает альтернативу async action creator, перемещая асинхронную логику в middleware. Это позволяет нам тестировать и концентрировать весь асинхронный код приложения в одном месте.

### <a name="Reducer-Tests">Тесты для Reducer</a>

Тестирование reducer очень похоже на тестирование action creator, поскольку reducer по определению является идемпотентным (используя состояние и действие, каждый раз возвращает новое состояние).

Это делает написание тестов для reducer весьма простым, так как мы просто должны вызвать reducer c различными комбинациями входных данных и проверить правильность выходных.

#### Базовый тест для reducer

Для нашего теста мы должны создать очень "грубый" reducer, который может обрабатывать единственный action _ADD RECIPE_, а его состояние представляет собой массив с рецептами:

_Простой reducer для рецептов_
```javascript
import { ADD_RECIPE } from 'consts.js';
 
const reducer = (state = initialState, action) => {
  switch(action.type) {
    case ADD_RECIPE:
      return state.concat({ title: action.payload });
  }
 
  return state;
};
 
export default reducer;
```

Есть два основных тестовых случая, которые следует учитывать, добавляя рецепт в пустой и не пустой список. Мы можем проверить первый случай следующим образом:

_Простой тест reducer для рецептов_
```javascript
import reducer from 'reducers/recipes';
import { ADD_RECIPE } from 'consts';
 
describe("reducer для рецептов", () => {
  it('должен добавить рецепт в пустой список', () => {
    const initialState = [];
    const action       = { type: ADD_RECIPE, payload: 'test' };
    const expected     = [{ title: "test" }];
    const actual       = reducer(initialState, action);
 
    expect(actual).toEqual(expected);
  });
};
```

Шаги, предпринятые здесь, должны быть уже знакомы:

1. Вычисляем изначальное состояние (в данном случае пустой массив).
2. Создаем action для отправки.
3. Устанавливаем ожидаемое значение состояния, которое должен вернуть reducer.
4. Вызываем _reducer()_ для подсчета состояния основываясь на пустом массиве и нашем action.
5. Проверяем, что полученное и ожидаемое значения равны.

Прежде чем мы упростим код, рассмотрим второй тестовый пример, добавив рецепт в непустой список:

_Тест добавления рецепта в не пустой список_
```javascript
it('должен добавить рецепт в не пустой список', () => {
  const initialState = [{ title: "first" }];
  const action       = { type: ADD_RECIPE, payload: 'test' };
  const expected     = [{ title: "first" }, { title: "test" }];
  const actual       = reducer(initialState, action);
 
  expect(actual).toEqual(expected);
});
```

В этом тесте мы начинаем с списка, содержащего один элемент, и обновляем ожидаемый результат. Хотя это работает, у него есть проблема. Что случится, если наши рецепты будут содержать больше полей в будущем?

Используя этот метод написания тестов, мы вынуждены будем найти каждый тест содержащий изначальное состояние и добавить туда больше полей. Это усложняет работу по написанию тестов и не дает никаких преимуществ. К счастью, у нас есть способ создать не пустое состояние - reducer! Поскольку, в прошлом тесте, мы уже протестировали добавление рецепта в пустой список, мы можем полагаться на наш reducer, чтобы создать не пустой список со всей необходимой информацией о рецептах:

_Создание изначального состояния используя reducer_
```javascript
const initialState = reducer([], { type: ADD_RECIPE, payload: 'first' });
```

Это лишь частично решает проблему, поскольку мы все еще рассматриваем изначальное состояние как пустой массив ([]). Хотя это верно в нашем тестовом случае, другие reducer могут иметь более сложные структуры. Простым решением было бы создать _const initialState = []_ в корне тестов и при необходимости полагаться на него:

_Устанавливаем изначальное состояние для всех тестов_
```javascript
describe("reducer для рецептов", () => {
  const initialState = [];
 
  it('должен добавить рецепт в пустой список', () => {
    const action       = { type: ADD_RECIPE, payload: 'test' };
    const expected     = [{ title: "test" }];
    const actual       = reducer(initialState, action);
 
    expect(actual).toEqual(expected);
  });
 
  it('должен добавить рецепт в не пустой список', () => {
    const testState    = reducer(initialState, { type: ADD_RECIPE, payload: 'first' });
 
    const action       = { type: ADD_RECIPE, payload: 'test' };
    const expected     = [{ title: "first" }, { title: "test" }];
    const actual       = reducer(testState, action);
 
    expect(actual).toEqual(expected);
  });
};
```

Одно и тоже изначальное состояние использовать во всех тестах, но оно по прежнему жестко закодировано в нашем тестовом файле. Если наш reducer изменит способ создания состояния, мы будем вынуждены обновить и тестовые файлы соответственно. Что бы избежать этой зависимости мы можем положиться на функцию, которую предоставляет Redux - _combineReducers()_. Она предусматривает, что любой reducer, вызванный с неопределенным состоянием, должен вернуть свою часть изначального состояния:

_Часть нашего reducer_
```javascript
const initialState = [];
 
const reducer = (state = initialState, action) => {
  ...
};
```

Это означает, что мы можем использовать reducer, что бы получить изначальное состояние, для использования его в наших тестах. Для этого вызовем его с _undefined_ состоянием и любым action:

_Создание изначального состояния используя наш reducer_
```javascript
const initialState = reducer(undefined, { type: 'INIT' });
```

Результат этой операции поместит тот же [] в изначальное состояние, но теперь любые изменения того, что reducer считает исходным состоянием, будут автоматически получены и в тестах.

#### Делаем тесты более симпотичными

Теперь, когда мы решили все проблемы с функциональностью, мы можем использовать те же самые трюки, которые мы использовали в тестах action-creator, чтобы упростить наши тесты на reducer. Это изначальная структура тестового файла:

_Изначальный тест_
```javascript
const initialState = reducer(undefined, { type: 'INIT' });
 
it('должен добавить рецепт в пустой список', () => {
  const action   = { type: ADD_RECIPE, payload: 'test' };
  const expected = [{ title: "test" }];
 
  expect(reducer(initialState, action)).toEqual(expected);
});
 
it('должен добавить рецепт в не пустой список', () => {
  const baseState = reducer(initialState, { type: ADD_RECIPE, payload: 'first' });
  const action    = { type: ADD_RECIPE, payload: 'test' };
  const expected  = [{ title: "first" }, { title: "test" }];
  const actual    = reducer(baseState, action);
 
  expect(actual).toEqual(expected);
});
```

Первым шагом будет объединение _action_, _actual_ и _expected_ в одну строку:

_Упрощенные тесты_
```javascript
const initialState = reducer(undefined, { type: 'INIT' }); 
 
it('должен добавить рецепт в пустой список', () => {
  const expected = [{ title: "test" }];
 
  expect(reducer(initialState, { type: ADD_RECIPE, payload: 'test' }))
    .toEqual(expected);
});
 
it('должен добавить рецепт в не пустой список', () => {
  const baseState = reducer(initialState, { type: ADD_RECIPE, payload: 'first' });
  const expected  = [{ title: "first" }, { title: "test" }];
 
  expect(reducer(baseState, { type: ADD_RECIPE, payload: 'test' }))
    .toEqual(expected);
});
```

Второй шаг - использовать моментальные снимки (snapshot) Jest вместо вычисляемых вручную ожидаемых значений:

_Упрощенные тесты, шаг 2_
```javascript
it('должен добавить рецепт в пустой список', () => {
  expect(reducer(initialState, { type: ADD_RECIPE, payload: 'test' }))
    .toMatchSnapshot()
});
 
it('должен добавить рецепт в не пустой список', () => {
  const baseState = reducer(initialState, { type: ADD_RECIPE, payload: 'first' });
 
  expect(reducer(baseState, { type: ADD_RECIPE, payload: 'test' }))
    .toMatchSnapshot();
});
```

#### Избегание мутаций

Одним из ключевых требований является то, что наши reducer никогда не изменяют состояние, а только создают новое. Наши текущие тесты не отлавливают эти проблемы (попробуйте изменить _.concat()_ на _.push()_ в реализации reducer).

Хотя мы можем попытаться отловить эти ошибки, вручную проверив, что начальное состояние не изменилось, более простым способом было бы "заморозить" начальное состояние и внести любые изменения в нем будут автоматически останавливать тесты. Для этого мы можем использовать отличную библиотеку [deep-freeze](https://github.com/substack/deep-freeze):

_Установка deep-freeze_
```bash
npm install deep-freeze --save
```

Что бы использовать deep-freeze, мы обернем наше изначальное состояние вызовом _deepFreeze()_:

_Использование deep-freeze_
```javascript
import deepFreeze from 'deep-freeze';
  
const initialState = deepFreeze(reducer(undefined, { type: 'INIT' }));
```

Любая попытка изменить _initialState_ теперь автоматически выдает ошибку:
```javascript
initialState.push('test'); // -> TypeError: Can't add property 0, object is not extensible
```

Чтобы наши редукторы никогда не меняли исходное состояние, мы всегда можем вызвать _deepFreeze()_ для состояния, переданного в качестве первого параметра в reducer:

_Обновленный тест добавления в не пустой список_
```javascript
it('должен добавить рецепт в не пустой список', () => {
  const baseState = reducer(initialState, { type: ADD_RECIPE, payload: 'first' });
 
  expect(reducer(
      deepFreeze(baseState),
      { type: ADD_RECIPE, payload: 'test' }
    )
  ).toMatchSnapshot();
});
```

#### Action Creator и Reducer

Обычно при написании модульных тестов рекомендуется тестировать каждую часть системы отдельно, а в интеграционных тестах только взаимодействие и интерфейсы. В случае с Redux, стоит рассмотреть связь между action creator и reducer.

На данный момент мы реализовали наши тесты так, что объект действия _ADD_RECIPE_ определен в трех разных местах: action creator, тесты рецептов и тесты reducer.

Если в будущем мы решим изменить структуру действия _ADD_RECIPE_, наши тесты action creator отловят изменение и напомнят нам об обновлении тестового кода. Но тесты для reducer будут продолжать завершаться успешно, если мы забудем изменить жестко закодированные объекты действия _ADD_RECIPE_, используемые в этих тестах.

Это может привести к болезненным случаям, когда все тесты проходят, но система не работает. Чтобы этого избежать, мы можем прекратить использовать жестко закодированные объекты действия в reducer и напрямую полагаться на action creator:

_Измененные тесты reducer для использования action creator_
```javascript
it('должен добавить рецепт в пустой список', () => {
  expect(reducer(initialState, addRecipe('test'))).toMatchSnapshot()
});
 
it('должен добавить рецепт в не пустой список', () => {
  const baseState = deepFreeze(reducer(initialState, addRecipe('first')));
 
  expect(reducer(baseState, addRecipe('test'))).toMatchSnapshot();
});
```

Хотя это и нарушает принцип написания модульных тестов, объединение reducer с action creator приводит к более чистому коду, уменьшению количества ошибок и меньшему дублированию.

#### Неизвестные действия

Последний вопрос связанный с тестированием reducer заключается в том, что он обрабатывают неизвестные действия и возвращают исходное состояние, переданное им без изменений.

>Поскольку каждый action может распространяться на все дерево reducer, важно, чтобы reducer возвращал исходное состояние, а не модифицированную копию. Это позволит библиотекам пользовательского интерфейса идентифицировать изменения в дереве с помощью сравнения ссылок.

Мы можем сделать это следующим образом:

_Тест неизвестных действий_
```javascript
it('должен обработать неизвестное действие', () => {
  expect(reducer(initialState, { type: 'FAKE' })).toBe(initialState);
});
```

Важным моментом для этого теста является использование _.toBe()_ вместо _.toEqual()_ или _.toMatchSnapshot()_. В отличие от других методов _.toBe_() ожидает, что результатом редуктора будет тот же самый объект, а не похожий объект с теми же данными:

_Пример использования toBe_
```javascript
const a = { name: 'Kipi' };
const b = { name: 'Kipi' };
 
it('пройденный тест', () => {
  expect(a).toEqual(b);
});
 
it('проваленный тест', () => {
  expect(a).toBe(b);
});
```

Основная цель этого теста - проверить, что наш редуктор возвращает исходное состояние, если отправленное действие не предназначалось для него:

_Корректный код для reducer_
```javascript
const reducer = (state = initialState, action) => {
  switch(action.type) {
    case ADD_RECIPE: return state.concat({ title: action.payload })
  }
 
  return state;
};
```

### <a name="Testing-Middleware">Тестирование Middleware</a>

...