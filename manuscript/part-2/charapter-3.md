# <a name="Part-2">Использование в реальном мире</a>

## <a name="Сharapter-3">Глава 3. Управление состоянием</a>

Одной из основных преимуществ Redux является разделение состояния (данных) с презентационными и логическими уровнями. Из-за разделения обязанностей разработка схемы состояния может выполняться отдельно от разработки пользовательского интерфейса и любых сложных логических потоков.

### <a name="The-Concept-of-Separation">Общее представление разделения</a>

Чтобы проиллюстрировать эту концепцию, рассмотрим наше приложение для рецептов. Приложение может управлять несколькими книгами рецептов, каждая из которых имеет несколько рецептов. Рецепт, в свою очередь, представляет собой объект, содержащий список ингредиентов, инструкции по приготовлению, изображения и так далее:

_Простая структура состояния приложения_
```javascript
const state = {
  books: [
    {
      id: 21,
      name: 'Breakfast',
      recipes: [
        {
          id: 63,
          name: 'Omelette',
          favorite: true,
          preparation: 'How to prepare...',
          ingredients: [...]
        },
        {...},
        {...}
      ]
    },
    {...},
    {...}
  ]
};
```

Хотя эта схема состояния содержит всю необходимую информацию и точно соответствует описанию нашего приложения, он имеет пару проблем:

* [Вложенный и связанный reducer](#Reducer-Nesting-and-Coupling)
* [Доступ к нескольким вложенных объектов данных](#Access-to-Multiple-Nested-Data-Entities)

#### <a name="Reducer-Nesting-and-Coupling">Вложенный и связанный reducer</a>

Давайте попробуем реализовать reducer, который поддерживает action, добавляющий новый ингредиент в рецепт.

Существуют два основных подхода: первый, где несколько reducer в цепочке знают об одном и том же текущем действии и второй, где каждый reducer передает информацию только своим детям.

Давайте узнаем в чем могут скрываться проблемы и как мы можем с ними справится. Первый подход может быть реализован следующим образом:

_Несколько Reducer знающих об одном action_
```javascript
const booksReducer = (state, action) => {
  switch(action.type) {
    case ADD_INGREDIENT:
      return Object.assign({}, state, {
        books: state.books.map(
          book => book.id !== action.payload.bookId
            ? book
            : recipesReducer(book, action)
        )
      });
  }
};
 
const recipesReducer = (book, action) => {
  switch(action.type) {
    case ADD_INGREDIENT:
      return Object.assign({}, book, {
        recipes: book.recipes.map(
          recipe => recipe.id !== action.payload.recipeId
            ? recipe
            : ingredientsReducer(recipe, action)
        )
      });
  }
};
 
const ingredientsReducer = (recipe, action) => {
  // Обычный reducer
};
```

В этой реализации каждый «родительский» reducer должен знать о любых action, используемых в дочерних. Любые изменения или дополнения потребуют от нас проверки нескольких reducer на изменение кода. Это рушит все преимущества от разделения reducer и значительно усложняет наш код.

Второй вариант заключается в том, что reducer передают все action своим детям:

_Reducer передающий action_

```javascript
const booksReducer = (books, action) => {
  const newBooks = handleBookActions(books, action);
 
  // Обратимся к reducer, который обрабатывает рецепты
  return newBooks.map(book => Object.assign({}, book, {
    recipes: recipesReducer(book.recipes, action)
  }));
};
 
const recipesReducer = (recipes, action) => {
  const newRecipes = handleRecipeActions(book, action);
 
  // Обратимся к reducer, который обрабатывает ингредиенты
  return newRecipes.map(recipe => Object.assign({}, recipe, {
    ingredients: ingredientsReducer(recipe.ingredients, action)
  }));
};
```

В этой реализации мы разделяем логику reducer на две части, одна из которых позволяет запускать любые дочерние reducer, а вторая - обрабатывать action самого reducer. 

Хотя эта реализация не требует, чтобы родитель знал о action, поддерживаемых его детьми, мы вынуждены запускать очень большое количество reducer для каждого рецепта. Один вызов action, не связанного с рецептами, например _UPDATE_PROFILE_, будет запускать _recipesReducer()_ для каждого рецепта и в свою очередь запускать _ingredientsReducer()_ для каждого из ингредиентов.

#### <a name="Access-to-Multiple-Nested-Data-Entities">Доступ к нескольким вложенным объектам данных</a>

Другая проблема с подходом вложенного состояния заключается в извлечении данных. Если мы хотим показать все любимые рецепты пользователя, нам нужно отсканировать все книги, чтобы найти их:

_Получение списка любимых рецептов_
```javascript
const getFavorites = (state) => {
  const recipes = state.books.map(
    book => book.filter(recipe => favorite)
  );
 
  // Удалите все нулевые значения
  return recipes.filter(recipe => recipe);
};    
```

Кроме того, поскольку этот код (или аналогичный) будет использоваться для пользовательского интерфейса, любые изменения в структуре состояния необходимо будет отражать не только в reducer, но и в самом пользовательском интерфейсе. Такой подход рушит преимущества разделение того, что касается модели и может потребовать значительных изменений в уровне пользовательского интерфейса, если изменится структура состояния.

### <a name="State-as-a-Database">Состояние как база данных</a>

Рекомендуемый подход для решения различных вопросов, поднятых выше, заключается в рассмотрении состояния приложения как базы данных объектов. В нашем примере мы сломаем вложенность, чтобы сделать наше состояние как можно более мелким, а свяжем их используя ID:

_Нормализованное состояние_
```javascript
const state = {
  books: {
    21: {
      id: 21,
      name: 'Breakfast',
      recipes: [63, 78, 221]
    }
  },
 
  recipes: {
    63: {
      id: 63,
      book: 21,
      name: 'Omelette',
      favorite: true,
      preparation: 'How to prepare...',
      ingredients: [152, 121]
    },
    78: {},
    221: {}
  },
 
  ingredients: {}
};
```

В этой структуре каждый объект имеет свой собственный ключ в корне нашего состояния. Любые связи между объектами (например, ингредиенты, используемые в рецепте) могут быть выражены с помощью обычного упорядоченного массива идентификаторов (ID).

#### Вложенный и связанный reducer

Давайте рассмотрим реализацию reducer, необходимых для обработки действия (action) _ADD_INGREDIENT_, используя новое состояние:

_Reducer для добавления нового ингредиента_
```javascript
const booksReducer = (books, action) => {
  // Больше не связано с ингредиентами
};
 
const recipeReducer = (recipe, action) => {
  switch (action.type) {
    case ADD_INGREDIENT:
      return Object.assign({}, recipe, {
        ingredients: [...recipe.ingredients, action.payload.id]
      });
  }
 
  return recipe;
};
 
const recipesReducer = (recipes, action) => {
  switch(action.type) {
 
    case ADD_INGREDIENT:
      return recipes.map(recipe =>
        recipe.id !== action.payload.recipeId
          ? recipe
          : recipesReducer(recipe, action));
  }
};
 
const ingredientsReducer = (ingredients, action) => {
  switch (action.type) {
    case ADD_INGREDIENT:
      return [...ingredients, action.payload]
  }
};
```

В этой реализации есть две вещи который нужно отметить, по сравнению с тем, что мы видели с денормализованным состоянием:

* Reducer для обработки книг даже не упоминается. Уровни вложенности влияют только на непосредственных потомков, не ниже. 
* Reducer для рецептов добавляет в массив ингредиентов только ID, а не весь компонент ингредиента.

Что бы воспользоваться этим примером в дальнейшем, реализация _UPDATE_RECIPE_ не потребует никаких изменений в reducer для рецептов, так как он может полностью обрабатываться только лишь одним reducer для ингредиентов.

#### Доступ к нескольким вложенных объектов данных

Получение списка любимых рецептов намного проще в нормализованном состоянии, поскольку нам нужно всего лишь отсканировать "таблицу" рецептов. Это можно сделать в пользовательском интерфейсе, используя функцию, называемую селектором (selector). Если думать о состоянии как базе данных, то можно представить селектор как запрос к базе данных:

_Избранные рецепты_
```javascript
const getFavorites = (state) =>
  state.recipes.filter(recipe => favorite);
```

Основное улучшение заключается в том, что нам не нужно знать структуру или уровни вложенности состояния для доступа к глубоко вложенной информации. Скорее, мы рассматриваем наше состояние как обычную базу данных, из которой извлекается информация для пользовательского интерфейса.

### <a name="Keeping-a-Normalized-State">Хранение нормализованного состояния</a>

Хотя нормализованное состояние может показаться отличной идеей, часто данные, возвращаемые с сервера, структурированы глубоко вложенным образом. Возможный пример полученных данных может выглядеть так:

_Полученные данные_
```javascript
{
  id: 63,
  name: 'Omelette',
  favorite: true,
  preparation: 'How to prepare...',
  ingredients: [
    {
      id: 5123,
      name: 'Egg',
      quantity: 2
    },
    {
      id: 729,
      name: 'Milk',
      quantity: '2 cups'
    }
  ]
};
```

Поскольку единственный способ обновить хранилище (store) Redux - это отправить action в reducer, мы должны создать payload (полезную нагрузку), которую можно легко обработать нашими reducer и найти способ извлечь payload из денормализованных данных, возвращенных сервером.

#### Создание общего action

Потенциально, мы хотели бы, чтобы каждый из наших reducer, работающих с данных, мог обрабатывать специальный action UPDATE_DATA и извлекать нужные ему части:

_Образец действия (action) UPDATE_DATA_
```javascript
const updateData = ({
  type: UPDATE_DATA,
  payload: {
    recipes: {
      63: {
        id: 63,
        name: 'Omelette',
        favorite: true,
        preparation: 'How to prepare...',
        ingredients: [5123, 729]
      }
    },
    ingredients: {
      5123: {
        id: 5123,
        name: 'Egg',
        quantity: 2
      },
      729: {
        id: 729,
        name: 'Milk',
        quantity: '2 cups'
      }
    }
  }
});
```

Используя этот подход, наш reducer рецептов, поддерживающий action UPDATE_DATA, будет выглядеть так:

_Reducer рецептов поддерживающий действие UPDATE_DATA_
```javascript
const recipesReducer = (state, action) => {
  switch(action.type) {
    case UPDATE_DATA:
      if (!('recipes' in action.payload)) return state;

      return Object.assign({}, state, {
        recipes: Object.assign({},
          state.recipes,
          action.payload.recipes
        )
      });
  }
};
```

Наш reducer проверяет, содержит ли payload какие-либо рецепты и объединяет новые данные со старым объектом рецептов (таким образом, добавляя или иным образом модифицируя его по мере необходимости).

#### Нормализация данных

Мы обновили reducer и определили структуру action, однако осталось еще проблема с извлечением payload из денормализованных данных, полученных с сервера.

Прямым подходом может быть создание пользовательской функции, которая знает API всех возвращаемых данных и нормализует возвращенный вложенный JSON в плоскую структуру.

Поскольку это довольно распространенная практика, пользовательский код может быть заменен библиотекой [normalizr](https://github.com/paularmstrong/normalizr). Используя эту библиотеку, мы можем определить схему данных, поступающих с сервера, и получить нормализованную структуру, которую мы можем передать непосредственно в наш action UPDATE_DATA.

### <a name="Persisting-State">Сохранение состояния</a>

Во многих случаях мы хотим сохранить текущее состояние даже во время обновления страницы или закрытия вкладки приложения. Самый простой способ - сохранить его в локальном хранилище браузера (local storage). Чтобы легко синхронизировать наш store с local storage (или любым другим механизмом хранения), мы можем использовать библиотеку [redux-persist](https://github.com/rt2zz/redux-persist). Она будет автоматически сохранить наше состояние после его изменения.

Чтобы использовать библиотеку, просто установите ее с помощью npm и отредактируйте файл создания store, обернув _createStore_ с помощью "усилителя" (enhancer):

_Настройка redux-persist_
```javascript
import { createStore } from 'redux';
import { persistStore, autoRehydrate } from 'redux-persist';
import rootReducer from 'reducers/root';
 
const store = createStore(rootReducer, autoRehydrate());
 
persistStore(store);
```

После вызова _persistStore(store)_ наш store и local storage браузера будут автоматически синхронизироваться, и наш store останется после обновления страницы.

#### Продвинутая синхронизация store

В библиотеке _redux-persist_ есть расширенная функциональность, которая позволит нам сохранять только часть состояния или указывать специальные сериализаторы для части состояния, которая не может быть сериализована с помощью _JSON.stringify()_ (функции, символы и так далее). Мы рекомендуем вам просмотреть документацию библиотеки для получения более подробной информации о более сложных функциях.

### <a name="Real-World-State">Состояние в реальном проекте</a>

В реальном приложении наше состояние обычно содержит несколько разных объектов, включая сами данные приложения (предпочтительно нормализованные) и вспомогательные данные (например, текущий токен доступа, ожидание уведомления и другие).

#### Структура общего состояния

В отличие от данных, поступающих с сервера, некоторая информация будет использоваться исключительно нашим внешним приложением для его внутренних потребностей. Распространенный пример - хранение общего количества активных запросов на на сервер в очереди, для того чтобы знать отображать ли прелоадер. Или у нас может быть свойство _currentUser_, где мы сохраняем информацию о текущем пользователе, такую как имя пользователя и токен доступа:

_Пример состояния_
```javascript
const state = {
  books: { },
  recipes: { },
  ingredients: { },
  ui: {
    activeRequests: 0
  },
  currentUser: {
    name: 'Kipi',
    accessToken: 'topsecrettoken'
  }
};
```

По мере роста нашего приложения, наше состояние будет включать в себя все больше различных объектов. Некоторые из них будут поступать из внешних библиотек, таких как _redux-forms_ и _react-redux-router_. Другим необходимо место непосредственно в state. Они будут появляться в зависимости от бизнес логики нашего приложения.

Например, если нам необходимо поддерживать редактирование профиля пользователя с возможностью отмены, наша реализация может создать новый временный ключ, в котором мы будем хранить копию профиля во время его редактирования. Как только пользователь нажмет «подтвердить» или «отменить», временная копия будет либо скопирована, чтобы стать новым профилем, либо просто удалена.

#### Хранение управляемого состояния

Чтобы сделать эти вещи максимально простыми, лучше всего иметь reducer для каждого ключа в основном состоянии. Это позволит сразу же выяснить кто какие части состояния может модифицировать. Для очень крупного проекта было бы полезно разделить «server data» (данные с сервера) и «auxilary/temp data» (вспомогательные/временные данные) под разными корневыми ключами:

_Состояние с большой вложенностью_
```javascript
const state = {
  db: {
    books: { },
    recipes: { },
    ingredients: { },
  },
  local: {
    ui: {
      activeRequests: 0
    },
    user: {
      name: 'Kipi',
      accessToken: 'topsecrettoken'
    }
  },
  vendor: {
    forms: {},
    router: {}
  }
}; 
```

Такой подход позволяет упростить управление различными частями при принятии решения о том, что необходимо синхронизировать с local storage или при очистке устаревших данных.

В общем, state является некой базой данных для frontend разработчика и его стоит рассматривать как таковое. Важно периодически проверять текущий state и делать какой-либо рефакторинг, чтобы убедиться, что его структура чиста, понятна и проста в расширении.

#### Что помещать в состояние

Общей проблемой при работе с Redux является выбор того, какая информация находится внутри нашего состояния и что осталось за ее пределами - в состоянии React, в сервисах Angular, либо в других методах хранения различных библиотек и фреймворков.

Вот несколько вопросов, которые необходимо учитывать при принятии решения о добавлении чего-либо в состояние:

* Должны ли эти данные сохраняться после обновления страницы?
* Должны ли эти данные сохраняться после изменения маршрута (route)?
* Используются ли эти данные в нескольких местах пользовательского интерфейса?

Если ответ на любой из этих вопросов «да», данные должны хранится в состоянии. Если ответ на все эти вопросы «нет», данные все равно можно разместить в состоянии, но это не обязательно.

Несколько примеров данных, которые могут храниться за пределами state:

* Текущая открытая вкладка на странице (имеется ввиду выбранная вкладка из нескольких внутри страницы, если таковые имеются)
* Открытие/закрытое состояние модального окна
* Текущие отображаемые ошибки

Мы можем считать это похожим на помещение данных в базу данных или временное хранение в памяти. Некоторая информация может быть безопасно потеряна, не искажая пользовательские данные.

### <a name="Summary-3">Подведем итоги</a>

В этой главе мы обсудили структуру нашего состояния Redux и как им следует управлять для упрощения интеграции с reducer и пользовательским интерфейсом. Мы также узнали, что состояние следует рассматривать как базу данных приложения и разрабатывать отдельно от презентационных или логических уровней.

В следующей главе мы поговорим о взаимодействии с сервером, о лучшем методе отправки данных на сервер и получения их с сервера, используя middleware.

<a href="https://github.com/Zveroboev/The-Complete-Redux-Book#Table-of-contents">К оглавлению</a>